=head1 NAME

perldebug - Perl debugging

=head1 DESCRIPTION

=head2 Debugging

If you invoke I<perl> with a B<-d> switch, your script will be run
under a debugging monitor.  It will halt before the first executable
statement and ask you for a command, such as:

=over 12

=item h

Prints out a help message.

=item T

Stack trace.

=item s

Single step.  Executes until it reaches the beginning of another
statement.

=item n

Next.  Executes over subroutine calls, until it reaches the beginning
of the next statement.

=item f

Finish.  Executes statements until it has finished the current
subroutine.

=item c

Continue.  Executes until the next breakpoint is reached.

=item c line

Continue to the specified line.  Inserts a one-time-only breakpoint at
the specified line.

=item <CR>

Repeat last n or s.

=item l min+incr

List incr+1 lines starting at min.  If min is omitted, starts where
last listing left off.  If incr is omitted, previous value of incr is
used.

=item l min-max

List lines in the indicated range.

=item l line

List just the indicated line.

=item l

List next window.

=item -

List previous window.

=item w line

List window around line.

=item l subname

List subroutine.  If it's a long subroutine it just lists the
beginning.  Use "l" to list more.

=item /pattern/

Regular expression search forward for pattern; the final / is optional.

=item ?pattern?

Regular expression search backward for pattern; the final ? is optional.

=item L

List lines that have breakpoints or actions.

=item S

Lists the names of all subroutines.

=item t

Toggle trace mode on or off.

=item b line condition

Set a breakpoint.  If line is omitted, sets a breakpoint on the line
that is about to be executed.  If a condition is specified, it is
evaluated each time the statement is reached and a breakpoint is taken
only if the condition is true.  Breakpoints may only be set on lines
that begin an executable statement.

=item b subname condition

Set breakpoint at first executable line of subroutine.

=item d line

Delete breakpoint.  If line is omitted, deletes the breakpoint on the
line that is about to be executed.

=item D

Delete all breakpoints.

=item a line command

Set an action for line.  A multi-line command may be entered by
backslashing the newlines.

=item A

Delete all line actions.

=item < command

Set an action to happen before every debugger prompt.  A multi-line
command may be entered by backslashing the newlines.

=item > command

Set an action to happen after the prompt when you've just given a
command to return to executing the script.  A multi-line command may be
entered by backslashing the newlines.

=item V package

List all variables in package.  Default is main package.

=item ! number

Redo a debugging command.  If number is omitted, redoes the previous
command.

=item ! -number

Redo the command that was that many commands ago.

=item H -number

Display last n commands.  Only commands longer than one character are
listed.  If number is omitted, lists them all.

=item q or ^D

Quit.

=item command

Execute command as a perl statement.  A missing semicolon will be
supplied.

=item p expr

Same as "print DB'OUT expr".  The DB'OUT filehandle is opened to
/dev/tty, regardless of where STDOUT may be redirected to.

=back

If you want to modify the debugger, copy perldb.pl from the perl
library to your current directory and modify it as necessary.  (You'll
also have to put -I. on your command line.)  You can do some
customization by setting up a .perldb file which contains
initialization code.  For instance, you could make aliases like these:

    $DB'alias{'len'} = 's/^len(.*)/p length($1)/';
    $DB'alias{'stop'} = 's/^stop (at|in)/b/';
    $DB'alias{'.'} =
      's/^\./p "\$DB\'sub(\$DB\'line):\t",\$DB\'line[\$DB\'line]/';

