=head1 NAME

perlvar - Perl predefined variables

=head1 DESCRIPTION

=head2 Predefined Names

The following names have special meaning to I<perl>.  I could have used
alphabetic symbols for some of these, but I didn't want to take the
chance that someone would say reset "a-zA-Z" and wipe them all out.
You'll just have to suffer along with these silly symbols.  Most of
them have reasonable mnemonics, or analogues in one of the shells.

=over 8

=item $_

The default input and pattern-searching space.  The following pairs are
equivalent:

    while (<>) {...}	# only equivalent in while!
    while ($_ = <>) {...}

    /^Subject:/
    $_ =~ /^Subject:/

    y/a-z/A-Z/
    $_ =~ y/a-z/A-Z/

    chop
    chop($_)

(Mnemonic: underline is understood in certain operations.)

=item $.

The current input line number of the last filehandle that was read.
Readonly.  Remember that only an explicit close on the filehandle
resets the line number.  Since <> never does an explicit close, line
numbers increase across ARGV files (but see examples under eof).
(Mnemonic: many programs use . to mean the current line number.)

=item $/

The input record separator, newline by default.  Works like I<awk>'s RS
variable, including treating blank lines as delimiters if set to the
null string.  You may set it to a multicharacter string to match a
multi-character delimiter.  Note that setting it to "\n\n" means
something slightly different than setting it to "", if the file
contains consecutive blank lines.  Setting it to "" will treat two or
more consecutive blank lines as a single blank line.  Setting it to
"\n\n" will blindly assume that the next input character belongs to the
next paragraph, even if it's a newline.  (Mnemonic: / is used to
delimit line boundaries when quoting poetry.)

=item $,

The output field separator for the print operator.  Ordinarily the
print operator simply prints out the comma separated fields you
specify.  In order to get behavior more like I<awk>, set this variable
as you would set I<awk>'s OFS variable to specify what is printed
between fields.  (Mnemonic: what is printed when there is a , in your
print statement.)

=item $"

This is like $, except that it applies to array values interpolated
into a double-quoted string (or similar interpreted string).  Default
is a space.  (Mnemonic: obvious, I think.)

=item $\

The output record separator for the print operator.  Ordinarily the
print operator simply prints out the comma separated fields you
specify, with no trailing newline or record separator assumed.  In
order to get behavior more like I<awk>, set this variable as you would
set I<awk>'s ORS variable to specify what is printed at the end of the
print.  (Mnemonic: you set $\ instead of adding \n at the end of the
print.  Also, it's just like /, but it's what you get "back" from
I<perl>.)

=item $#

The output format for printed numbers.  This variable is a half-hearted
attempt to emulate I<awk>'s OFMT variable.  There are times, however,
when I<awk> and I<perl> have differing notions of what is in fact
numeric.  Also, the initial value is %.20g rather than %.6g, so you
need to set $# explicitly to get I<awk>'s value.  (Mnemonic: # is the
number sign.)

=item $%

The current page number of the currently selected output channel.
(Mnemonic: % is page number in nroff.)

=item $=

The current page length (printable lines) of the currently selected
output channel.  Default is 60.  (Mnemonic: = has horizontal lines.)

=item $-

The number of lines left on the page of the currently selected output
channel.  (Mnemonic: lines_on_page - lines_printed.)

=item $~

The name of the current report format for the currently selected output
channel.  Default is name of the filehandle.  (Mnemonic: brother to
$^.)

=item $^

The name of the current top-of-page format for the currently selected
output channel.  Default is name of the filehandle with "_TOP"
appended.  (Mnemonic: points to top of page.)

=item $|

If set to nonzero, forces a flush after every write or print on the
currently selected output channel.  Default is 0.  Note that I<STDOUT>
will typically be line buffered if output is to the terminal and block
buffered otherwise.  Setting this variable is useful primarily when you
are outputting to a pipe, such as when you are running a I<perl> script
under rsh and want to see the output as it's happening.  (Mnemonic:
when you want your pipes to be piping hot.)

=item $$

The process number of the I<perl> running this script.  (Mnemonic: same
as shells.)

=item $?

The status returned by the last pipe close, backtick (``) command or
I<system> operator.  Note that this is the status word returned by the
wait() system call, so the exit value of the subprocess is actually ($?
>> 8).  $? & 255 gives which signal, if any, the process died from, and
whether there was a core dump.  (Mnemonic: similar to sh and ksh.)

=item $&

The string matched by the last successful pattern match (not counting
any matches hidden within a BLOCK or eval enclosed by the current
BLOCK).  (Mnemonic: like & in some editors.)

=item $`

The string preceding whatever was matched by the last successful
pattern match (not counting any matches hidden within a BLOCK or eval
enclosed by the current BLOCK).  (Mnemonic: ` often precedes a quoted
string.)

=item $'

The string following whatever was matched by the last successful
pattern match (not counting any matches hidden within a BLOCK or eval
enclosed by the current BLOCK).  (Mnemonic: ' often follows a quoted
string.)  Example:

    $_ = 'abcdefghi';
    /def/;
    print "$`:$&:$'\n";  	# prints abc:def:ghi

=item $+

The last bracket matched by the last search pattern.  This is useful if
you don't know which of a set of alternative patterns matched.  For
example:

    /Version: (.*)|Revision: (.*)/ && ($rev = $+);

(Mnemonic: be positive and forward looking.)

=item $*

Set to 1 to do multiline matching within a string, 0 to tell I<perl>
that it can assume that strings contain a single line, for the purpose
of optimizing pattern matches.  Pattern matches on strings containing
multiple newlines can produce confusing results when $* is 0.  Default
is 0.  (Mnemonic: * matches multiple things.)  Note that this variable
only influences the interpretation of ^ and $.  A literal newline can
be searched for even when $* == 0.

=item $0

Contains the name of the file containing the I<perl> script being
executed.  Assigning to $0 modifies the argument area that the ps(1)
program sees.  (Mnemonic: same as sh and ksh.)

=item $<digit>

Contains the subpattern from the corresponding set of parentheses in
the last pattern matched, not counting patterns matched in nested
blocks that have been exited already.  (Mnemonic: like \digit.)

=item $[

The index of the first element in an array, and of the first character
in a substring.  Default is 0, but you could set it to 1 to make
I<perl> behave more like I<awk> (or Fortran) when subscripting and when
evaluating the index() and substr() functions.  (Mnemonic: [ begins
subscripts.)

=item $]

The string printed out when you say "perl -v".  It can be used to
determine at the beginning of a script whether the perl interpreter
executing the script is in the right range of versions.  If used in a
numeric context, returns the version + patchlevel / 1000.  Example:


    # see if getc is available
    ($version,$patchlevel) =
	     $] =~ /(\d+\.\d+).*\nPatch level: (\d+)/;
    print STDERR "(No filename completion available.)\n"
	     if $version * 1000 + $patchlevel < 2016;

or, used numerically,

    warn "No checksumming!\n" if $] < 3.019;

(Mnemonic: Is this version of perl in the right bracket?)

=item $;

The subscript separator for multi-dimensional array emulation.  If you
refer to an associative array element as

    $foo{$a,$b,$c}

it really means

    $foo{join($;, $a, $b, $c)}

But don't put

    @foo{$a,$b,$c}	# a slice--note the @

which means

    ($foo{$a},$foo{$b},$foo{$c})

Default is "\034", the same as SUBSEP in I<awk>.  Note that if your
keys contain binary data there might not be any safe value for $;.
(Mnemonic: comma (the syntactic subscript separator) is a
semi-semicolon.  Yeah, I know, it's pretty lame, but $, is already
taken for something more important.)

=item $!

If used in a numeric context, yields the current value of errno, with
all the usual caveats.  (This means that you shouldn't depend on the
value of $! to be anything in particular unless you've gotten a
specific error return indicating a system error.)  If used in a string
context, yields the corresponding system error string.  You can assign
to $! in order to set errno if, for instance, you want $! to return the
string for error n, or you want to set the exit value for the die
operator.  (Mnemonic: What just went bang?)

=item $@

The perl syntax error message from the last eval command.  If null, the
last eval parsed and executed correctly (although the operations you
invoked may have failed in the normal fashion).  (Mnemonic: Where was
the syntax error "at"?)

=item $<

The real uid of this process.  (Mnemonic: it's the uid you came FROM,
if you're running setuid.)

=item $>

The effective uid of this process.  Example:

    $< = $>;		# set real to effective uid
    ($<,$>) = ($>,$<);	# swap real and effective uid

(Mnemonic: it's the uid you went TO, if you're running setuid.)  Note:
$< and $> can only be swapped on machines supporting setreuid().

=item $(

The real gid of this process.  If you are on a machine that supports
membership in multiple groups simultaneously, gives a space separated
list of groups you are in.  The first number is the one returned by
getgid(), and the subsequent ones by getgroups(), one of which may be
the same as the first number.  (Mnemonic: parentheses are used to GROUP
things.  The real gid is the group you LEFT, if you're running setgid.)

=item $)

The effective gid of this process.  If you are on a machine that
supports membership in multiple groups simultaneously, gives a space
separated list of groups you are in.  The first number is the one
returned by getegid(), and the subsequent ones by getgroups(), one of
which may be the same as the first number.  (Mnemonic: parentheses are
used to GROUP things.  The effective gid is the group that's RIGHT for
you, if you're running setgid.)

Note: $<, $>, $( and $) can only be set on machines that support the
corresponding set[re][ug]id() routine.  $( and $) can only be swapped
on machines supporting setregid().

=item $:

The current set of characters after which a string may be broken to
fill continuation fields (starting with ^) in a format.  Default is "
\n-", to break on whitespace or hyphens.  (Mnemonic: a "colon" in
poetry is a part of a line.)

=item $^A

The current value of the write accumulator for format lines.

=item $^D

The current value of the debugging flags.  (Mnemonic: value of B<-D>
switch.)

=item $^F

The maximum system file descriptor, ordinarily 2.  System file
descriptors are passed to subprocesses, while higher file descriptors
are not.  During an open, system file descriptors are preserved even if
the open fails.  Ordinary file descriptors are closed before the open
is attempted.

=item $^I

The current value of the inplace-edit extension.  Use undef to disable
inplace editing.  (Mnemonic: value of B<-i> switch.)

=item $^L

What formats output to perform a formfeed.  Default is \f.

=item $^P

The internal flag that the debugger clears so that it doesn't debug
itself.  You could conceivable disable debugging yourself by clearing
it.

=item $^T

The time at which the script began running, in seconds since the
epoch.  The values returned by the B<-M>, B<-A> and B<-C> filetests are
based on this value.

=item $^W

The current value of the warning switch.  (Mnemonic: related to the
B<-w> switch.)

=item $^X

The name that Perl itself was executed as, from argv[0].

=item $ARGV

contains the name of the current file when reading from <>.

=item @ARGV

The array ARGV contains the command line arguments intended for the
script.  Note that $#ARGV is the generally number of arguments minus
one, since $ARGV[0] is the first argument, NOT the command name.  See
$0 for the command name.

=item @INC

The array INC contains the list of places to look for I<perl> scripts
to be evaluated by the "do EXPR" command or the "require" command.  It
initially consists of the arguments to any B<-I> command line switches,
followed by the default I<perl> library, probably
"/usr/local/lib/perl", followed by ".", to represent the current
directory.

=item %INC

The associative array INC contains entries for each filename that has
been included via "do" or "require".  The key is the filename you
specified, and the value is the location of the file actually found.
The "require" command uses this array to determine whether a given file
has already been included.

=item $ENV{expr}

The associative array ENV contains your current environment.  Setting a
value in ENV changes the environment for child processes.

=item $SIG{expr}

The associative array SIG is used to set signal handlers for various
signals.  Example:

    sub handler {	# 1st argument is signal name
	local($sig) = @_;
	print "Caught a SIG$sig--shutting down\n";
	close(LOG);
	exit(0);
    }

    $SIG{'INT'} = 'handler';
    $SIG{'QUIT'} = 'handler';
    ...
    $SIG{'INT'} = 'DEFAULT';	# restore default action
    $SIG{'QUIT'} = 'IGNORE';	# ignore SIGQUIT

The SIG array only contains values for the signals actually set within
the perl script.

=back

