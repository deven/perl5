=head1 NAME

perlsub - Perl subroutines

=head1 SYNOPSIS

    sub I<name>;
    sub I<name> { I<statements> }

    &I<name>
    &I<name>(LIST);
    I<name>(LIST);
    I<name> LIST;	# Only if predeclared.

=head1 DESCRIPTION

A subroutine may be declared as follows:

    sub NAME BLOCK

Any arguments passed to the routine come in as array @_, that is
($_[0], $_[1], ...).  The array @_ is a local array, but its values are
references to the actual scalar parameters.  The return value of the
subroutine is the value of the last expression evaluated, and can be
either an array value or a scalar value.  Alternately, a return
statement may be used to specify the returned value and exit the
subroutine.  To create local variables see the I<local> and I<my>
operators.

A subroutine may called using the & prefix.  (The & is optional in Perl 5.)

Example:

    sub MAX {
	local($max) = pop(@_);
	foreach $foo (@_) {
	    $max = $foo if $max < $foo;
	}
	$max;
    }

    ...
    $bestday = &MAX($mon,$tue,$wed,$thu,$fri);

Example:

    # get a line, combining continuation lines
    #  that start with whitespace
    sub get_line {
	$thisline = $lookahead;
	line: while ($lookahead = <STDIN>) {
	    if ($lookahead =~ /^[ \t]/) {
		$thisline .= $lookahead;
	    }
	    else {
		last line;
	    }
	}
	$thisline;
    }

    $lookahead = <STDIN>;	# get first line
    while ($_ = get_line()) {
	...
    }

Use array assignment to a local list to name your formal arguments:

    sub maybeset {
	local($key, $value) = @_;
	$foo{$key} = $value unless $foo{$key};
    }

This also has the effect of turning call-by-reference into
call-by-value, since the assignment copies the values.

Subroutines may be called recursively.  If a subroutine is called using
the & form, the argument list is optional.  If omitted, no @_ array is
set up for the subroutine; the @_ array at the time of the call is
visible to subroutine instead.

    &foo(1,2,3);	# pass three arguments
    foo(1,2,3);		# the same

    foo();		# pass a null list
    &foo();		# the same
    &foo;		# pass no arguments--more efficient

=head2 Passing By Reference

Sometimes you don't want to pass the value of an array to a subroutine
but rather the name of it, so that the subroutine can modify the global
copy of it rather than working with a local copy.  In perl you can
refer to all the objects of a particular name by prefixing the name
with a star: *foo.  When evaluated, it produces a scalar value that
represents all the objects of that name, including any filehandle,
format or subroutine.  When assigned to within a local() operation, it
causes the name mentioned to refer to whatever * value was assigned to
it.  Example:

    sub doubleary {
	local(*someary) = @_;
	foreach $elem (@someary) {
	    $elem *= 2;
	}
    }
    doubleary(*foo);
    doubleary(*bar);

Assignment to *name is currently recommended only inside a local().
You can actually assign to *name anywhere, but the previous referent of
*name may be stranded forever.  This may or may not bother you.

Note that scalars are already passed by reference, so you can modify
scalar arguments without using this mechanism by referring explicitly
to the $_[nnn] in question.  You can modify all the elements of an
array by passing all the elements as scalars, but you have to use the *
mechanism to push, pop or change the size of an array.  The * mechanism
will probably be more efficient in any case.

Since a *name value contains unprintable binary data, if it is used as
an argument in a print, or as a %s argument in a printf or sprintf, it
then has the value '*name', just so it prints out pretty.

Even if you don't want to modify an array, this mechanism is useful for
passing multiple arrays in a single LIST, since normally the LIST
mechanism will merge all the array values so that you can't extract out
the individual arrays.

