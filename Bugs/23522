Article 23522 of comp.lang.perl:
Path: netlabs!news.cerf.net!mvb.saic.com!MathWorks.Com!europa.eng.gtefsd.com!news.umbc.edu!haven.umd.edu!ames!koriel!male.EBay.Sun.COM!jethro.Corp.Sun.COM!eric
From: eric.arnold@sun.com (Eric Arnold)
Newsgroups: comp.lang.perl
Subject: tie questions
Date: 21 Jun 94 01:48:59 GMT
Organization: Sun Microsystems
Lines: 103
Sender: news@sun.com
Message-ID: <ERIC.94Jun21014859@sun.com>
References: <2u4d7kINNa15@life.ai.mit.edu>
NNTP-Posting-Host: animus.corp.sun.com
X-Newsreader: prn Ver 1.09


What should this do?:
	
	tie $x, S1;
	$x = \@a;		# optionally
	$x->[0] = 3;

It causes either an error or a destroy/untie.  Shouldn't it assign an
[anon] list reference to $x?  I'd like it to, but I don't know if it ever
will, since it mightn't be a bug.  Also, this dumps core:

	tie %x, H1;
	$x{"A"}->[0] = 3;
	package H1;
	sub new{ bless {} }
with message:
	Attempt to free temp prematurely at ./tsttie5 line 2.	

I'd also like to understand just what's supposed to be going on with a
tied variable.  A tied variable looks superficially like an "object",
since the tie package "new" function "bless"es a reference like an
object package does.  However, a tied variable behaves differently in
other ways to an object.  For example, you can't do:
	$x->fetch();

I have the feeling that there some special whammy placed on a
tied variable that defies deduction?

Another thing I noticed was that "print @a" doesn't call "fetch()"
for a tied "@a".

Lastly, I was musing that "tie" might be a good way to implement
"structures" (a la "C"), as an alternative to using object methods for
structure elements like in a previous post by Tom Christiansen.  "tie"
would allow you to predefine the valid elements of an associative
array, for example.  E.g:


  tie %x, H1, "key1", "val1", "key2", "val2";
  while(<STDIN>){
    ($k,$v)=split;			# E.g type:  key1 valxxx
    print "before: k=$k=",$x{$k},"\n";
    $x{$k}=$v;
    print "after: k=$k=",$x{$k},"\n";
  }

  package H1;
  sub new   { 
    local( $x, $pkgnm ) = ( {}, shift );
    %{$x} = @_;
    for ( keys %{$x} ){
      $x->{"_DEFINED_"}->{$_}++; }
    bless $x; 
  }
  sub fetch { my ($this,$k)=@_; &check( $this, $k ); return $this->{$k}; }
  sub check{ my ($this,$k)=@_; 
    die "Undefined element $k" unless $this->{"_DEFINED_"}->{$k}; }
  sub store { my ($this,$k,$v)=@_; &check( $this, $k ); $this->{$k}=$v; }
  DESTROY   { print "H1 destroy \@_=(@_) \n"; }

This still doesn't get you compile time type checking, but it's
easier to assign to an assoc array, than to a method.

-Eric


P.S.  This illustrates some problems:


tie $x, S1;

#print "following should do ??? :\n";
#$x->[0] = 3;		# it causes a destroy, thereby untying

@a = ( 1, 2, 3 );
$x = \@a;		# Ok: causes store, and extra "new"
print "should cause a fetch: \$x=(",$x,")\n";
print "should cause a store:\n";		# ok
$a[0] = 3;					# ok

#print "following should cause a fetch and store (?):\n";
#$x->[0] = 3;	# it doesn't cause store, it causes:
		# Can't use SCALAR ref as an ARRAY ref at ./tsttie3 line 18.
		# and stops the script

print "should cause a fetch: \@a=",@a,"\n";	# not ok, @a form not supported?
print "should cause a fetch: \$a[0]=",$a[0],"\n";
print "should cause a fetch: \$x=", $x, "\n";	# ok
untie $x;

package S1;

sub new   { local $x; print "S1 new \@_=(@_) , bless:",\$x,"\n"; bless \$x; }
sub fetch { print "S1 fetch \@_=(@_) \n"; return $_[0]; }
sub store { print "S1 store \@_=(@_) \n"; tie @{$_[1]},A1; }
DESTROY   { print "S1 destroy \@_=(@_) \n"; }

package A1;

sub new   { local @x; print "A1 new \@_=(@_) ,bless:",\@x,"\n"; bless \@x; }
sub fetch { print "A1 fetch \@_=(@_) \n"; my($l,$e)=@_;return ${$l}[$e]; }
sub store { print "A1 store \@_=(@_) \n"; my $this=$_[0];$this->[$_[1]]=$_[2];}
DESTROY   { print "A1 destroy \@_=(@_) \n"; }


