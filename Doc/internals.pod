=head1 TITLE

Perl's Internal Functions

=head1 DATE

Draft 7: 1994/9/30

=head1 AUTHOR

By Jeff Okamoto

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, and Neil Bowers.

=head1 DATATYPES
Perl has three typedefs that handle perl's three main data types:

	SV	Scalar Value
	AV	Array Value
	HV	Hash Value

Each typedef has specific routines that manipulate the various data type.

=head2 WHAT IS AN "IV"?

Perl uses a special typedef IV which is large enough to hold either an
integer or a pointer.

Perl also uses a special typedef I32 which is the size of an integer on
the specific platform.  Usually this is 32 bits.

=head2 WORKING WITH SV's

An SV can be created and loaded with one command.  There are four types of
values that can be loaded: an integer value (IV), a double, a string, and
another scalar.

The four routines are:

	SV *sv = newSViv(IV);
	SV *sv = newSVnv(double);
	SV *sv = newSVpv(char *, int);
	SV *sv = newSVsv(SV *);

To change the value of an *already-existing* scalar, there are five routines:

	void	sv_setiv(SV *, IV);
	void	sv_setnv(SV *, double);
	void	sv_setpvn(SV *, char *, int)
	void	sv_setpv(SV *, char *);
	void	sv_setsv(SV *, SV *);

Notice that you can choose to specify the length of the string to be assigned,
or allow perl to calculate the length (using strlen()).

To access the actual value that an SV points to, you can use the macros:

	SvIV(SV *)
	SvNV(SV *)
	SvPV(SV *, len)

which will automagically coerce the actual scalar type into an IV, double,
or string.

In the SvPV macro, the length of the string returned is placed into the
variable len (this is a macro, so you do NOT use &len).  If you do not
care what the length of the data is, use the global variable na.  Remember,
however, that Perl allows arbitary strings of data that may both contain
NUL's and not be terminated by a NUL.

You can get and set the current length of the string stored in an SV with
the following macros:

	SvCUR(SV *)
	SvCUR_set(SV *, I32 val)

Although perl will automatically grow strings for you, if you need to force
perl to allocate more memory for your SV, you can use the function:

	sv_grow(SV *, I32 newlen)

Note that sv_grow can only increase, not decrease, the allocated memory of
an SV.

If you have an SV and want to know what kind of data perl thinks is stored
in it, you can use the following macros to check the type of SV you have.

	SvIOKp(SV *)
	SvNOKp(SV *)
	SvPOKp(SV *)

If you know the name of a scalar variable, you can get a pointer to its SV
by using the following:

	SV *sv = perl_get_sv("varname", FALSE);

The scalar undef value is stored in an SV instance called sv_undef.  Its
address can be used whenever an SV* is needed.

Do not be fooled into thinking that (ST *) 0 is the same as &sv_undef.
Take this code:

	SV *sv = (SV *) 0;
	if (i-should-return-a-real-value) {
		sv = sv_2mortal(newSViv(42));
	}
	sv_setsv(ST(0), sv);

This code tries to return a new SV (which contains the value 42) if it should
return a real value, or undef otherwise.  Instead it has returned a null
pointer which, somewhere down the line, will cause a segmentation violation,
or just weird results.  Change the zero to &sv_undef in the first line, and
all will be well.

=head2 WORKING WITH AV's

There are two ways to create and load an AV.  The first method just creates
an empty AV:

	AV *av = newAV();

The second method both creates the AV and initially populates it with SV's:

	AV *av = av_make(I32 num, SV **ptr);

The second argument points to an array containing num SV *'s.

Once the AV has been created, the following operations are possible on AV's:

	void	av_push(AV *, SV *);
	SV*	av_pop(AV* ar);
	SV*	av_shift(AV* ar);
	void	av_unshift(AV* ar, I32 num);

These should be familiar operations.

	I32	av_len(AV* ar);	/* Returns length of array */

	SV**	av_fetch(AV* ar, I32 key, I32 lval);
			/* Fetches value at key offset, but it seems to
			   set the value to lval if non-zero */
	SV**	av_store(AV* ar, I32 key, SV* val);
			/* Stores val at offset key */

	void	av_clear(AV* ar);
			/* Clear out all elements, but leave the array */
	void	av_undef(AV* ar);
			/* Undefines the array, removing all elements */

If you know the name of an array variable, you can get a pointer to its AV
by using the following:

	AV *av = perl_get_av("varname", FALSE);

=head2 WORKING WITH HV's

To create an HV, you use the following routine:

	HV *hv = newHV();

Once the HV has been created, the following operations are possible on HV's:

	SV**	hv_store(HV* hv, char* key, U32 klen, SV* val, U32 hash);
	SV**	hv_fetch(HV* hv, char* key, U32 klen, I32 lval);

The klen parameter is the length of the key being passed in.  Val contains
the SV pointer to the scalar being stored, and hash is the pre-computed hash
value (zero if you want hv_store to calculate it for you).  The lval parameter
indicates whether this fetch is actually a part of a store operation.

These two functions check if a hash table entry exists, and deletes it.

	bool	hv_exists(HV* hv, char* key, U32 klen);
	SV*	hv_delete(HV* hv, char* key, U32 klen);

And now for more miscellaneous functions:

	void	hv_clear(HV* hv);
			/* Clears all entries in hash table */
	void	hv_undef(HV* hv);
			/* Undefines the hash table */

	I32	hv_iterinit(HV* hv);
			/* Prepares starting point to traverse hash table */
	HE*	hv_iternext(HV* hv);
			/* Get the next entry, and return a pointer to a
			   structure that has both the key and value */
	char*	hv_iterkey(HE* entry, I32* retlen);
			/* Get the key from an HE structure and also return
			   the length of the key string */
	SV*	hv_iterval(HV* hv, HE* entry);
			/* Return a SV pointer to the value of the HE
			   structure */

If you know the name of a hash variable, you can get a pointer to its HV
by using the following:

	HV *hv = perl_get_hv("varname", FALSE);

=head2 REFERENCES

References are a special type of scalar that point to other scalar types
(including references).  To convert an AV or HV to a scalar, it is simply
a matter of casting an AV or HV to an SV.

To create a reference, use the following command:

	SV *rv = newRV((SV *) pointer);

Once you have a reference, you can use the following macro with a cast to
the proper typedef (SV, AV, HV):

	SvRV(SV *)

then call the appropriate routines, casting the returned SV* to either an
AV* or HV*.

To determine, after dereferencing a reference, if you still have a reference,
you can use the following macro:

	SvROK(SV *)

=head1 XSUB'S AND THE ARGUMENT STACK

The XSUB mechanism is a simple way for perl programs to access C subroutines.
An XSUB routine will have a stack that contains the arguments from the perl
program, and a way to map from the perl data structures to a C equivalent.

The stack arguments are accessible through the ST(n) macro, which returns
the n'th stack argument.  Argument 0 is the first argument passed in the
perl subroutine call.  These arguments are SV*, and can be used anywhere
an SV* is used.

Most of the time, output from the C routine can be handled through use of
the RETVAL and OUTPUT directives.  However, there are some cases where the
argument stack is not already long enough to handle all the return values.
An example is the POSIX tzname() call, which takes no arguments, but returns
two, the local timezone's standard and summer time abbreviations.

To handle this situation, the PPCODE directive is used and the stack is
extended using the macro:

	EXTEND(sp, num);

where sp is the stack pointer, and num is the number of elements the stack
should be extended by.

Now that there is room on the stack, values can be pushed on it using the
macros to push IV's, doubles, strings, and SV pointers respectively:

	PUSHi(IV)
	PUSHn(double)
	PUSHp(char *, I32)
	PUSHs(SV *)

And now the perl program calling tzname, the two values will be assigned
as in:

	($standard_abbrev, $summer_abbrev) = POSIX::tzname;

An alternate (and possibly simpler) method to pushing values on the stack is
to use the macros:

	XPUSHi(IV)
	XPUSHn(double)
	XPUSHp(char *, I32)
	XPUSHs(SV *)

These macros automatically adjust the stack for you, if needed.

=head1 MORTALITY

In perl, values are normally "immortal" -- that is, they are not freed unless
explicitly done so (via the perl undef call or other routines in perl itself).

In the above example with tzname, we needed to create two new SV's to push
onto the argument stack, that being the two strings.  However, we don't want
these new SV's to stick around forever because they will eventually be
copied into the SV's that hold the two scalar variables.

An SV (or AV or HV) that is "mortal" still acts as the appropriate type,
but is automatically freed when the current context in which the mortal
value was allocated.  Generally this means the current statement.

The call to create a mortal variable is:

	SV *	sv_newmortal()
	SV *	sv_2mortal(SV *)
	SV *	sv_mortalcopy(SV *)

The first call creates a mortal SV, the second converts an existing SV to
a mortal SV, the third creates a mortal copy of an existing SV.

The mortal routines are not just for SV's -- AV's and HV's can be made mortal
by passing their address (and typecast to SV*) to the sv_2mortal or
sv_mortalcopy routines.

=head1 CREATING NEW VARIABLES

To create a new perl variable, which can be accessed from your perl script,
use the following routines, depending on the variable type.

	SV *sv = perl_get_sv("varname", TRUE);
	AV *av = perl_get_av("varname", TRUE);
	HV *hv = perl_get_hv("varname", TRUE);

Notice the use of TRUE as the second parameter.  The new variable can now
be set, using the routines appropriate to the data type.

=head1 STASHES and OBJECTS

A stash is a hash table (associative array) that contains all of the
different objects that are contained within a package.  This includes
(but may not be limited to) the following:
	
	Scalar Values
	Array Values
	Hash Values
	File/Directory Handles
	Formats
	Subroutines
	Globs

Perl stores various stashes in a GV structure (for global variable) but
represents them with an HV structure.

To get the HV pointer for a particular package, use the function:

	HV *hv = gv_stashpv(char *name, I32 create)
	HV *hv = gv_stashsv(SV *, I32 create)

The first function takes a literal string, the second uses the string stored
in the SV.

The name that gv_stash*v wants is the name of the package whose symbol table
you want.  The default package is called "main".  If you have multiply nested
packages, it is legal to pass their names to gv_stash*v.

If you need to return a blessed value to your perl script, you can use the
following function:

	SV *sv = sv_bless(SV *, HV *)

where the first argument, an SV pointer, must be a reference, and the second
argument is a stash.  The returned SV can now be used in the same way as any
other SV.
