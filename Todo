Modules needed
	X/Motif/Tk etc.
	Curses

Tie Modules
	VecArray		Implement array using vec()
	SubstrArray		Implement array using substr()
	VirtualArray		Implement array using a file
	ShiftSplice		Defines shift et al in terms of splice method

Would be nice to have
	Profiler
	pack "(stuff)*"
	Contiguous bitfields in pack/unpack
	lexperl
	Bundled perl preprocessor
	Use posix calls internally where possible
	const variables
	gettimeofday
	bytecompiler
	format BOTTOM
	$obj->can("method") to probe method inheritance
	-iprefix.
	-i rename file only when successfully changed
	All ARGV input should act like <>
	Multiple levels of warning
	.= shouldn't complain about undefined under -w
	report HANDLE [formats].
	tie(FILEHANDLE, ...)
	__DATA__
	support in perlmain to rerun debugger
	make 'r' print return value like gdb 'fini'

Possible pragmas
	debugger
	optimize (use less memory, CPU)

Optimizations
	constant function cache
	switch structures
	foreach(@array)
	foreach (1..1000000)
	foreach(reverse...)
	Set KEEP on constant split
	Cache eval tree (unless lexical outer scope used (mark in &compiling?))
	rcatmaybe
	Shrink opcode tables via multiple implementations selected in peep
	Cache hash value?  (Not a win, according to Guido)
	Optimize away @_ where possible
	sfio?
	"one pass" global destruction
	Optimize sort by { $a <=> $b }
	Rewrite regexp parser for better integrated optimization

Vague possibilities
	ref function in list context
	Populate %SIG at startup if appropriate
	sub mysplice(@, $, $, ...)
	data prettyprint function?  (or is it, as I suspect, a lib routine?)
	Nested destructors
	make tr/// return histogram in list context?
	undef wantarray in void context
	Loop control on do{} et al
	Explicit switch statements
	perl to C translator
	multi-thread scheduling
	built-in globbing
	compile to real threaded code
	structured types
	paren counting in tokener to queue remote expectations
	autocroak?
	Modifiable $1 et al
	substr EXPR,OFFSET,LENGTH,STRING
	locally capture warnings into an array

