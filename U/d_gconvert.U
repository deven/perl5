?RCS: $Id: d_gconvert.U,v $
?RCS:
?RCS: $Log: d_gconvert.U,v $
?RCS:
?MAKE:d_Gconvert : cc ccflags libs Inlibc rm
?MAKE:	-pick add $@ %<
?S:d_Gconvert:
?S:	This variable holds what Gconvert is defined as to convert
?S:	floating point numbers into strings. It could be 'gconvert'
?S:	or a more complex macro emulating gconvert with gcvt() or sprintf.
?S:.
?C:Gconvert:
?C:	This preprocessor macro is defined to convert a floating point
?C:	number to a string without a trailing decimal point.  This
?C:	emulates the behavior of sprintf("%g"), but is sometimes much more
?C:	efficient.  If gconvert() is not available, but gcvt() drops the
?C:	trailing decimal point, then gcvt() is used.  If all else fails,
?C:	a macro using sprintf("%g") is used.
?C:.
?H:#define Gconvert(x,n,t,b) $d_Gconvert
?H:.
?T: d_gconvert d_gcvt
: see if gconvert exists
set gconvert d_gconvert
eval $inlibc

case "$d_gconvert" in
$define)
	d_Gconvert="gconvert((x),(n),(t),(b))"
	;;
*)
	: Maybe we can emulate it with gcvt.
	set gcvt d_gcvt
	eval $inlibc

	case "$d_gcvt" in
	$define) 
		: Test whether gcvt drops a trailing decimal point
		cat >try.c <<'EOP'
main() { 
char buf[64]; 
gcvt(1.0, 8, buf); 
return (buf[0] == '1' && buf[1] == '\0') ? 0 : 1 ;
}
EOP
		if $cc $ccflags -o try try.c $libs > /dev/null 2>&1; then
			if ./try; then
				echo "Good, your gcvt() drops a trailing decimal point."
				d_Gconvert="gcvt((x),(n),(b))"
			else
				echo "But your gcvt() keeps a trailing decimal point".
			fi
		else
			echo "Hmm.  I can't compile the gcvt test program."
		fi
		$rm -f try.c try

		;;
	esac
	case "$d_Gconvert" in
	'')
		echo "I'll use sprintf instead." >&4
		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
		;;
	esac
esac

